import _ from 'lodash';
import { type } from '../../../utils';
import { DataComponent } from '../data';
import Language from './language';

export default function LanguageComponent(dataComponent) {
    type.check(dataComponent, DataComponent);

    const languages = {};
    let defaultLanguageCode = null;

    return type.create(LanguageComponent, {
        getDefault() {
            if (_.isNull(defaultLanguageCode)) {
                const defaultLanguageData = _.find(dataComponent.getLanguages(), 'isDefault');

                if (!defaultLanguageData) {
                    throw new Error('There is no language set as default.');
                }

                buildLanguageChain(defaultLanguageData);
                defaultLanguageCode = defaultLanguageData.code;
            }

            return languages[defaultLanguageCode];
        },

        getByCode(code) {
            if (!languages[code]) {
                const languageData = getLanguageData(code);

                if (!languageData) {
                    throw new Error(`Unknown language: "${code}"`);
                }

                buildLanguageChain(languageData);
            }

            return languages[code] || null;
        },

        getAll() {
            const languagesData = dataComponent.getLanguages();
            if (_.size(languages) !== _.size(languagesData)) {
                const missingLanguagesData = _.reject(languagesData, l => languages[l.code]);
                _.each(missingLanguagesData, l => {
                    // it could have been added as fallback already
                    if (!languages[l]) {
                        buildLanguageChain(l);
                    }
                });
            }

            return languages;
        },
    });

    function buildLanguageChain(fromLanguageData) {
        const languageDataChain = [fromLanguageData];
        let nextCode = fromLanguageData.fallbackLanguageCode;
        let previousCode = fromLanguageData.code;
        let fallbackLanguage = null;

        while (!_.isNull(nextCode)) {
            if (languages[nextCode]) {
                fallbackLanguage = languages[nextCode];
                break;
            }

            const nextLanguageData = getLanguageData(nextCode);

            if (!nextLanguageData) {
                throw new Error(`Unknown fallback language: "${nextCode}" (for "${previousCode}")`);
            }

            if (containsLanguageData(languageDataChain, nextLanguageData)) {
                throw new Error('Languages fallback chain is not acyclic');
            }

            languageDataChain.push(nextLanguageData);
            previousCode = nextCode;
            nextCode = nextLanguageData.fallbackLanguageCode;
        }

        _.forEachRight(languageDataChain, ({ code, englishName, isDefault, localName }) => {
            languages[code] = Language({
                code,
                englishName,
                isDefault,
                localName,
            }, fallbackLanguage);

            fallbackLanguage = languages[code];
        });
    }

    function getLanguageData(code) {
        return _.find(dataComponent.getLanguages(), l => l.code === code);
    }

    function containsLanguageData(container, { code }) {
        return _.some(container, l => l.code === code);
    }
}

