import moment from 'moment-timezone';
import { type, check } from '../../../utils';
import CultureInfoComponent from '../cultureInfos/cultureInfoComponent';
import Year from '../years/year';
import Month from '../months/month';
import { IsoFormat, MomentLocalizationFormat } from '../enums';
import { format, parseString, toMoment, unformat, isValidFormat } from '../utils';
import DateFactory from './date';

export default function DateComponent(cultureInfoComponent) {
    type.check(cultureInfoComponent, CultureInfoComponent);

    return type.create(DateComponent, {
        parse(dateString, timezone) {
            check.string(dateString);
            check.timezone(timezone);
            check.notUtcTimezone(timezone);

            const m = parseString(dateString, timezone, IsoFormat.Date.value);
            return DateFactory(m);
        },

        today(timezone) {
            check.timezone(timezone);
            check.notUtcTimezone(timezone);

            const m = moment.tz(timezone);
            return DateFactory(m);
        },

        toMonth(date) {
            return Month(toDateMoment(date));
        },

        toYear(date) {
            return Year(toDateMoment(date));
        },

        toString(date, localization) {
            return format(toDateMoment(date), localization, MomentLocalizationFormat.Date.value, cultureInfoComponent);
        },

        fromString(dateString, timezone, localization) {
            return DateFactory(unformat(dateString, localization, 'dateFormat', cultureInfoComponent, timezone));
        },

        isValidString(dateString, localization) {
            return isValidFormat(dateString, localization, 'dateFormat', cultureInfoComponent);
        },

        toDayNameString(date, localization) {
            return format(toDateMoment(date), localization, MomentLocalizationFormat.Day.value, cultureInfoComponent);
        },

        toISOString(date) {
            return toDateMoment(date).format(IsoFormat.Date.value);
        },

        getYear(date) {
            return toDateMoment(date).year();
        },

        getMonth(date) {
            return toDateMoment(date).month();
        },

        getDate(date) {
            return toDateMoment(date).date();
        },

        getDayOfWeek(date) {
            return toDateMoment(date).day();
        },

        valueOf(date) {
            return toDateMoment(date).valueOf();
        },

        addDays(date, days) {
            check.number(days);

            var m = toDateMoment(date).add(days, 'days');
            return DateFactory(m);
        },

        addWeeks(date, weeks) {
            check.number(weeks);
            const m = toDateMoment(date).add(weeks, 'weeks');
            return DateFactory(m);
        },

        daysDiff(date1, date2) {
            check.sameTimezones(date1, date2);
            return toDateMoment(date1).diff(toDateMoment(date2), 'days');
        },

        isEqual(date1, date2) {
            check.sameTimezones(date1, date2);
            return toDateMoment(date1).isSame(toDateMoment(date2));
        },

        isLess(date1, date2) {
            check.sameTimezones(date1, date2);
            return toDateMoment(date1).isBefore(toDateMoment(date2));
        },

        isLessOrEqual,

        isGreater(date1, date2) {
            check.sameTimezones(date1, date2);
            return toDateMoment(date1).isAfter(toDateMoment(date2));
        },

        isGreaterOrEqual,

        min(date1, date2) {
            return isLessOrEqual(date1, date2) ? date1 : date2;
        },

        max(date1, date2) {
            return isGreaterOrEqual(date1, date2) ? date1 : date2;
        },

        clone(date) {
            return DateFactory(toDateMoment(date));
        },
    });
}

export function toDateMoment(date) {
    type.check(date, DateFactory);
    return toMoment(date.value, IsoFormat.Date.value, date.timezone);
}

function isLessOrEqual(date1, date2) {
    check.sameTimezones(date1, date2);
    return toDateMoment(date1).isSameOrBefore(toDateMoment(date2));
}

function isGreaterOrEqual(date1, date2) {
    check.sameTimezones(date1, date2);
    return toDateMoment(date1).isSameOrAfter(toDateMoment(date2));
}
