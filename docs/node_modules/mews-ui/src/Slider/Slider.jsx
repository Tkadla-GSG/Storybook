import _ from 'lodash';
import React, { Component, PropTypes as pt } from 'react';
import { KeyCode } from 'mews-js';
import { noop } from '../utils/func';
import { SliderElement, SliderTrackElement, KnobContainerElement, KnobElement, KnobFocusElement } from './style';

export default class Slider extends Component {
    static propTypes = {
        disabled: pt.bool,
        max: pt.number,
        min: pt.number,
        onChange: pt.func,
        step: pt.number,
        value: pt.number,
    };

    static defaultProps = {
        max: 100,
        min: 0,
        step: 1,
        value: 0,
        onChange: noop,
    };

    constructor(props) {
        super(props);

        this.handleMouseDown = this.createDownHandler('mousemove', 'mouseup');
        this.handleTouchStart = this.createDownHandler('touchmove', 'touchend', ({ targetTouches }) => targetTouches[0].pageX);

        this.state = {
            sliderLength: 0,
            sliderStart: 0,
            value: this.normalizeValue(props.value),
        };
    }

    componentDidMount() {
        window.addEventListener('resize', this.handleResize);
        this.handleResize();
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.value && nextProps.value !== this.props.value) {
            const normalizedValue = this.normalizeValue(nextProps.value);
            this.setState({ value: normalizedValue });
        }
    }

    componentWillUnmount() {
        window.removeEventListener('resize', this.handleResize);
    }

    setValueFromEvent(e, getPageX) {
        const pageX = getPageX(e);
        const value = this.computeValueFromPageX(pageX);
        this.setValue(value);
    }

    setValue(value) {
        if (value === this.state.value) {
            return;
        }

        const normalizedValue = this.normalizeValue(value);
        this.setState({ value: normalizedValue });
        this.props.onChange(normalizedValue);
    }

    createDownHandler(moveEvent, upEvent, getPageX = ({ pageX }) => pageX) {
        const moveHandler = e => {
            e.preventDefault();
            this.setValueFromEvent(e, getPageX);
        };

        const upHandler = () => {
            this.setState({ active: false });

            document.body.removeEventListener(moveEvent, moveHandler);
            document.body.removeEventListener(upEvent, upHandler);
        };

        const downHandler = e => {
            if (this.props.disabled) {
                return;
            }

            this.handleResize();
            this.setState({ active: true });
            this.preventFocusState = true;

            this.setValueFromEvent(e, getPageX);
            document.body.addEventListener(moveEvent, moveHandler);
            document.body.addEventListener(upEvent, upHandler);
        };

        return downHandler;
    }

    computeValueFromPageX(pageX) {
        const { max, min } = this.props;
        const { sliderLeft, sliderWidth } = this.state;
        const posX = pageX - sliderLeft;
        const percentage = posX / sliderWidth;

        // Fit the percentage complete between the range [min,max] by remapping from [0, 1] to [min, min+(max-min)].
        return min + (percentage * (max - min));
    }

    normalizeValue(value) {
        if (!_.isFinite(value)) {
            return this.props.min;
        }

        let finalValue = value;
        const { min, max, step } = this.props;

        const valueSetForBoundary = value === min || value === max;
        if (step && !valueSetForBoundary) {
            finalValue = this.quantizeValue(finalValue);
        }

        finalValue = _.clamp(finalValue, min, max);
        return finalValue;
    }

    quantizeValue(value) {
        const { step } = this.props;
        const stepsCount = Math.round(value / step);
        return stepsCount * step;
    }

    handleFocus = () => {
        if (this.preventFocusState) {
            return;
        }

        this.setState({ focused: true });
    };

    handleBlur = () => {
        this.preventFocusState = false;
        this.setState({ focused: false });
    };

    handleResize = () => {
        const rect = this.sliderElement.getBoundingClientRect();
        const left = rect.left;

        let width = rect.width;
        if (!width) {
            width = this.sliderElement.offsetWidth;
        }

        this.setState({
            sliderLeft: left,
            sliderWidth: width,
        });
    };

    handleKeyDown = e => {
        const keyCode = KeyCode.getByValue(e.which);

        let delta = NaN;
        switch (keyCode) {
            case KeyCode.Left:
                delta = -this.props.step;
                break;

            case KeyCode.Right:
                delta = this.props.step;
                break;

            default:
                break;
        }

        if (!_.isNaN(delta)) {
            e.preventDefault();
            this.setValue(this.state.value + delta);
        }
    };

    handleWheel = e => {
        if (this.props.disabled) {
            return;
        }

        const delta = (e.deltaY > 0 ? 1 : -1) * this.props.step;
        this.setValue(this.state.value + delta);
    };

    render() {
        const { disabled, max, min, ...other } = this.props;
        const { active, focused, sliderWidth, value } = this.state;

        const sliderProps = {
            innerRef: c => (this.sliderElement = c),
            onMouseDown: this.handleMouseDown,
            onTouchStart: this.handleTouchStart,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onKeyDown: this.handleKeyDown,
            onWheel: this.handleWheel,
            tabIndex: disabled ? undefined : 0,
        };

        const sliderTrackProps = {
            disabled,
            ref: c => (this.progressLinearComponent = c),
            max,
            min,
            value,
        };

        const knobTranslate = ((value - min) / (max - min)) * sliderWidth;
        const knobContainerProps = {
            ref: c => (this.knobComponent = c),
            onMouseDown: this.handleMouseDown,
            onTouchStart: this.handleTouchStart,
            style: {
                transform: `translateX(${knobTranslate}px) translateX(-50%)`,
            },
        };

        const knobProps = {
            disabled,
            active,
        };

        const knobFocusProps = {
            focused,
        };

        return (
            <SliderElement {...sliderProps}>
                <SliderTrackElement {...sliderTrackProps} />
                <KnobContainerElement {...knobContainerProps}>
                    <KnobElement {...knobProps} />
                    <KnobFocusElement {...knobFocusProps} />
                </KnobContainerElement>
            </SliderElement>
        );
    }
}
