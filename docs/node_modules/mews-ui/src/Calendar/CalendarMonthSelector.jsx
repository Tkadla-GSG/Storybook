import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { noop } from '../utils/func';
import { CalendarMonthSelectorElement, ScrollContainerElement, SelectableMonthElement } from './style';

const LOAD_THRESHOLD = 50;
const LOAD_AMOUNT = 10;

export default class CalendarMonthSelector extends Component {
    static propTypes = {
        getCalendarService: pt.func.isRequired,
        month: pt.any,
        onChange: pt.func,
    };

    static defaultProps = {
        onChange: noop,
    };

    constructor(props) {
        super(props);

        const { month } = props;
        const prevMonths = this.getPreviousMonths(month);
        const nextMonths = this.getNextMonths(month);

        this.state = {
            months: [...prevMonths, month, ...nextMonths],
        };

        this.monthElements = {};
    }

    componentDidMount() {
        /* This doesnt work with angular, it's hardcoded until we get rid of it in commander
        // hide scrollbar in scroll container
        const width = this.scrollElement.scrollWidth;
        this.monthSelectorElement.style.width = `${width}px`;
        */

        if (this.props.month) {
            setTimeout(() => this.scrollToMonth(this.props.month), 100);
        }
    }

    componentWillReceiveProps(nextProps) {
        const { month, getCalendarService } = nextProps;

        if (month && !getCalendarService().isMonthEqual(month, this.props.month)) {
            this.scrollToMonth(month);
        }
    }

    scrollToMonth(month) {
        const monthName = this.props.getCalendarService().getMonthName(month);
        const monthElement = this.monthElements[monthName];
        if (monthElement) {
            this.scrollElement.removeEventListener('scroll', this.handleScroll);
            smoothScroll(monthElement, this.scrollElement, () => {
                this.scrollElement.addEventListener('scroll', this.handleScroll);

                // handle possible scroll to the edge
                this.handleScroll();
            });
        }
    }

    addMonthsToTop() {
        const { months } = this.state;

        const firstMonth = months[0];
        const prevMonths = this.getPreviousMonths(firstMonth);

        this.setState({ months: [...prevMonths, ...months] });
    }

    addMonthsToBottom() {
        const { months } = this.state;

        const lastMonth = months[months.length - 1];
        const nextMonths = this.getNextMonths(lastMonth);

        this.setState({ months: [...months, ...nextMonths] });
    }

    getPreviousMonths(month) {
        const { getCalendarService } = this.props;
        const months = [];
        for (let i = LOAD_AMOUNT; i !== 0; --i) {
            months.push(getCalendarService().addMonths(month, -i));
        }

        return months;
    }

    getNextMonths(month) {
        const { getCalendarService } = this.props;
        const months = [];
        for (let i = 1; i !== LOAD_AMOUNT; ++i) {
            months.push(getCalendarService().addMonths(month, i));
        }

        return months;
    }

    handleScroll = () => {
        const { scrollTop } = this.scrollElement;

        if (scrollTop < LOAD_THRESHOLD) {
            this.addMonthsToTop();
        } else if (this.scrollElement.scrollHeight - scrollTop - this.scrollElement.offsetHeight < LOAD_THRESHOLD) {
            this.addMonthsToBottom();
        }
    };

    handleMonthClick = month => {
        if (!this.props.getCalendarService().isMonthEqual(month, this.props.month)) {
            this.props.onChange(month);
        }
    };

    render() {
        const { month, getCalendarService } = this.props;
        const { months } = this.state;

        return (
            <CalendarMonthSelectorElement innerRef={c => (this.monthSelectorElement = c)}>
                <ScrollContainerElement innerRef={c => (this.scrollElement = c)}>
                    {months.map(m => {
                        const monthName = getCalendarService().getMonthName(m);
                        const selected = getCalendarService().isMonthEqual(m, month);

                        return (
                            <SelectableMonthElement
                                key={monthName}
                                innerRef={c => (this.monthElements[monthName] = c)}
                                selected={selected}
                                month={m}
                                onMonthClick={this.handleMonthClick}
                            >
                                {monthName}
                            </SelectableMonthElement>
                        );
                    })}
                </ScrollContainerElement>
            </CalendarMonthSelectorElement>
        );
    }
}

const SCROLL_SPEED = 500;
// acceleration until halfway, then deceleration
const SCROLL_EASING = time => (time < 0.5
    ? 4 * (time ** 3)
    : ((time - 1) * ((2 * time) - 2) * ((2 * time) - 2)) + 1
);

function smoothScroll(target, scrollContainer, callback = () => {}) {
    const startLocation = scrollContainer.scrollTop;
    const endLocation = target.offsetTop - (scrollContainer.offsetHeight / 2);
    const distance = Math.abs(endLocation - startLocation);
    const distanceMagnitude = startLocation <= endLocation ? 1 : -1;

    const start = Date.now();
    const stepFunc = () => {
        const timeLapsed = Date.now() - start;
        const percentage = Math.min(timeLapsed / SCROLL_SPEED, 1);

        const scrolledDistance = distance * SCROLL_EASING(percentage) * distanceMagnitude;
        const position = startLocation + scrolledDistance;

        scrollContainer.scrollTop = position;
        if (position === endLocation) {
            return callback();
        }

        window.requestAnimationFrame(stepFunc);
    };

    window.requestAnimationFrame(stepFunc);
}
