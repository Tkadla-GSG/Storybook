import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { KeyCode } from 'mews-js';

import ListItem from './ListItem';
import { ListElement, ListItemsWrapperElement, FilterElement, FilterInputElement, FilterPlaceholderElement } from './style';

const KEYBOARD_SEARCH_TIMEOUT = 500;

const selectedPropType = pt.oneOfType([
    pt.string,
    pt.number,
]);

export default class List extends Component {
    static propTypes = {
        children: pt.node,
        innerRef: pt.func,
        navigable: pt.bool,
        onItemClick: pt.func,
        onChange: pt.func,

        cyclicNavigation: pt.bool,
        searchable: pt.bool,
        selectable: pt.bool,
        multiselect: pt.bool,
        filterable: pt.bool,

        dense: pt.bool,

        itemType: pt.any,
        selected: pt.oneOfType([selectedPropType, pt.arrayOf(selectedPropType)]),
    };

    static defaultProps = {
        innerRef: _.noop,
        navigable: false,
        onItemClick: _.noop,
        onChange: _.noop,
        onKeyDown: _.noop,

        cyclicNavigation: false,
        searchable: false,
        selectable: false,

        itemType: ListItem,
    };

    state = {
        selected: (this.props.selected && (this.props.multiselect ? this.props.selected : [this.props.selected])) || [],
        keyboardSearchString: '',
        filteredValues: null,
    };

    componentWillReceiveProps(nextProps) {
        if (nextProps.selected && !_.isEmpty(_.difference(this.state.selected, nextProps.selected))) {
            this.setState({ selected: this.props.multiselect ? nextProps.selected : [nextProps.selected] });
        }
    }

    handleKeyDown = event => {
        let handled = false;
        const isShift = event.shiftKey;
        const keyCode = KeyCode.getByValue(event.which);
        let direction;

        switch (keyCode) {
            case KeyCode.Enter:
                handled = true;
                this.handleItemClick(this.getActiveItem());
                break;

            case KeyCode.Up:
                handled = true;
                this.focusItem('prev');
                break;

            case KeyCode.Down:
                handled = true;
                this.focusItem('next');
                break;

            case KeyCode.Tab:
                direction = isShift ? 'prev' : 'next';
                handled = this.focusItem(direction);
                break;

            default:
                if (this.props.searchable && shouldHandleKey(event)) {
                    this.keyboardSearch(event);
                }
                break;
        }

        if (handled) {
            event.preventDefault();
            event.stopPropagation();
        } else {
            this.props.onKeyDown(event);
        }
    };

    findItemByValue(value) {
        return _.find(this.items, item => item.value === value);
    }

    getActiveItem() {
        return _.find(this.items, item => item.domElement === document.activeElement);
    }

    getActiveItemIndex() {
        return _.findIndex(this.items, item => item.domElement === document.activeElement);
    }

    focusItem(direction) {
        const firstIndex = 0;
        const lastIndex = this.items.length - 1;
        const activeItemIndex = this.getActiveItemIndex();

        let index;
        if (activeItemIndex === -1) {
            index = direction === 'next' ? firstIndex : lastIndex;
        } else {
            index = activeItemIndex + (direction === 'next' ? +1 : -1);
        }

        const isOutOfRange = index < firstIndex || index > lastIndex;
        if (!this.props.cyclicNavigation && isOutOfRange) {
            return false;
        }

        if (index < firstIndex) {
            index = lastIndex;
        }
        if (index > lastIndex) {
            index = firstIndex;
        }

        this.handleItemActivate(this.items[index]);
        return true;
    }

    keyboardSearch(event) {
        const nextChar = String.fromCharCode(event.which);

        const searchString = normalize(this.state.keyboardSearchString + nextChar);
        if (_.isEmpty(searchString)) {
            return;
        }

        if (!this.itemSearchValues) {
            this.itemSearchValues = _.map(this.items, i => normalize(i.getPrimaryText()));
        }

        if (this.clearKeyboardSearchTimeout) {
            clearTimeout(this.clearKeyboardSearchTimeout);
        }

        this.clearKeyboardSearchTimeout = setTimeout(() => {
            this.itemSearchValues = null;
            this.clearKeyboardSearchTimeout = null;
            this.setState({ keyboardSearchString: '' });
        }, KEYBOARD_SEARCH_TIMEOUT);

        const matchIndex = _.findIndex(this.itemSearchValues, v => _.startsWith(v, searchString));
        if (matchIndex !== -1) {
            const match = this.items[matchIndex];
            this.handleItemActivate(match);
        }

        this.setState({ keyboardSearchString: searchString });
    }

    handleItemActivate = item => {
        item.domElement.focus();
    };

    handleItemClick = item => {
        if (!item) {
            return;
        }

        const { value } = item.props;

        if (this.props.multiselect) {
            if (!_.isNil(value)) {
                const selected = _.xor([...this.state.selected], [value]);
                this.setState({ selected });
                this.props.onChange(selected);
            }
        }
        else if (this.props.selectable) {
            const selected = this.state.selected;
            if (!_.isNil(value) && selected[0] !== value) {
                selected[0] = value;
                this.setState({ selected });
                this.props.onChange(selected);
            }
        }

        this.handleItemActivate(item);
        this.props.onItemClick(item);
    };

    handleFilterChange = e => {
        const filterString = e.target.value;
        this.setState({ filterString });

        const normalizedFilterString = normalize(filterString);

        if (_.isEmpty(normalizedFilterString)) {
            this.setState({ filteredValues: null });
        } else {
            const filteredItems = _.filter(this.items, i => _.includes(normalize(i.getPrimaryText()), normalizedFilterString));
            this.setState({ filteredValues: filteredItems.map(i => i.props.value) });
        }
    };

    renderNodes() {
        const { filteredValues } = this.state;
        this.items = [];

        return React.Children.map(this.props.children, (c, index) => {
            if (_.isNil(c)) {
                return c;
            }

            if (c.type === this.props.itemType) {
                const value = c.props.value;

                return React.cloneElement(c, {
                    dense: this.props.dense,
                    key: index,
                    onClick: this.handleItemClick,
                    ref: item => {
                        if (item) {
                            this.items.push(item);
                        }
                    },
                    selected: _.includes(this.state.selected, value),
                    tabIndex: this.props.navigable ? 0 : null,
                    multiselect: this.props.multiselect,
                    hidden: filteredValues && !_.includes(filteredValues, value),
                });
            }

            return c;
        });
    }

    render() {
        const { innerRef, filterable, ...other } = this.props;
        delete other.itemType;

        const listProps = {
            ...other,
            innerRef: c => {
                this.list = c;
                innerRef(c);
            },
            onKeyDown: this.handleKeyDown,
        };

        let filter;
        if (filterable) {
            const { filterString } = this.state;

            filter = (
                <FilterElement>
                    <FilterInputElement onChange={this.handleFilterChange} />
                    {_.isEmpty(filterString) && <FilterPlaceholderElement>{this.props.filterPlaceholder}</FilterPlaceholderElement>}
                </FilterElement>
            );
        }

        return (
            <ListElement>
                {filter}
                <ListItemsWrapperElement {...listProps}>
                    {this.renderNodes()}
                </ListItemsWrapperElement>
            </ListElement>
        );
    }
}

function normalize(string) {
    return _.chain(string)
        .deburr()
        .toLower()
        .trim()
        .value();
}

function shouldHandleKey(event) {
    const char = String.fromCharCode(event.keyCode);
    const isNonUsefulKey = (event.keyCode <= 31);

    return (char && char.length && !isNonUsefulKey && !isMetaKey(event) && !isFnLockKey(event) && !hasModifierKey(event));
}

function isMetaKey(e) {
    return (e.keyCode >= 91 && e.keyCode <= 93);
}

function isFnLockKey(e) {
    return (e.keyCode >= 112 && e.keyCode <= 145);
}

function hasModifierKey(e) {
    return e.ctrlKey || e.metaKey || e.altKey;
}
