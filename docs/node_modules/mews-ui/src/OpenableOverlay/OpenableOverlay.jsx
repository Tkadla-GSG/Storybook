import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { KeyCode } from 'mews-js';

import { noop, debounce } from '../utils/func';
import ClickAway from '../ClickAway/ClickAway';
import Origin from './Origin';
import { OpenableOverlayElement } from './style';

const RESIZE_DEBOUNCE_TIMEOUT = 100;
const SCROLLBAR_SIZE = 20;
const BOUNCE_PADDING = 8;

class OpenableOverlay extends Component {
    static propTypes = {
        anchorElement: pt.oneOfType([pt.node, pt.func]),
        anchorOrigin: pt.instanceOf(Origin),
        children: pt.node,
        deregisterClickAway: pt.func,
        innerRef: pt.func,
        onOpen: pt.func,
        onClose: pt.func,
        onClickAway: pt.func,
        onKeyDown: pt.func,
        registerClickAway: pt.func,
        targetOrigin: pt.instanceOf(Origin),
        clickAway: pt.bool,
        opened: pt.bool,
    };

    static defaultProps = {
        innerRef: noop,
        onClose: noop,
        onKeyDown: noop,
        onOpen: noop,
        onClickAway: noop,

        anchorOrigin: Origin.TopLeft,
        targetOrigin: Origin.TopLeft,

        maxHeight: 500,
        clickAway: true,

        opened: false,
    };

    state = {
        placement: {
            top: 0,
            left: 0,
        },
    };

    componentWillMount() {
        this.resizeListener = debounce(() => this.checkPlacement(), RESIZE_DEBOUNCE_TIMEOUT);
        window.addEventListener('resize', this.resizeListener);
    }

    componentDidMount() {
        this.checkPlacement();
    }

    componentDidUpdate() {
        this.checkPlacement();
    }

    componentWillUnmount() {
        this.resizeListener.cancel();
        window.removeEventListener('resize', this.resizeListener);
    }

    handleClickAway = () => {
        this.props.onClickAway();
    };

    handleKeyDown = e => {
        const keyCode = KeyCode.getByValue(e.which);

        switch (keyCode) {
            case KeyCode.Esc:
                e.preventDefault();
                e.stopPropagation();

                this.close();
                break;

            default:
                break;
        }

        this.props.onKeyDown(e);
    };

    checkPlacement() {
        const { placement: { top, left } } = this.state;
        const placement = this.computePlacement();
        if (placement && (placement.top !== top || placement.left !== left)) {
            this.setState({ placement });
        }
    }

    computePlacement() {
        if (!this.props.opened) {
            return;
        }

        const { anchorElement, anchorOrigin, targetOrigin } = this.props;

        const realAnchorElement = _.isFunction(anchorElement) ? anchorElement() : anchorElement;
        const finalAnchorElement = realAnchorElement || this.root.parentNode;
        const targetElement = this.root;

        const anchorPosition = getTargetPosition(finalAnchorElement);
        const targetPosition = getTargetPosition(targetElement);

        const top = anchorPosition.vertical[anchorOrigin.vertical] - targetPosition.vertical[targetOrigin.vertical];
        let left = anchorPosition.horizontal[anchorOrigin.horizontal] - targetPosition.horizontal[targetOrigin.horizontal];

        const { innerWidth: viewportWidth } = window;
        const elementWidth = targetElement.offsetWidth;
        const anchorLeft = getElementLeft(finalAnchorElement);

        const absoluteElementLeft = left + anchorLeft;
        if (absoluteElementLeft < 0) {
            left += Math.abs(absoluteElementLeft) + BOUNCE_PADDING;
        }

        const absoluteLeftDiff = viewportWidth - (absoluteElementLeft + elementWidth);
        if (absoluteLeftDiff < 0) {
            const bouncedAbsoluteLeftDiff = absoluteLeftDiff + (Math.sign(absoluteLeftDiff) * (SCROLLBAR_SIZE + BOUNCE_PADDING));
            left += bouncedAbsoluteLeftDiff;
        }

        return { top, left };
    }

    registerHandlers() {
        if (this.props.clickAway) {
            this.hasRegisteredHandler = true;
            this.props.registerClickAway();
        }
    }

    deregisterHandlers() {
        if (this.hasRegisteredHandler) {
            this.hasRegisteredHandler = false;
            this.props.deregisterClickAway();
        }
    }

    open(anchorElement) {
        if (!this.state.isOpen) {
            this.setState({ isOpen: true });
            this.registerHandlers();

            // capture focus
            this.previouslyFocusedNode = document.activeElement;

            this.props.onOpen();
        }

        this.setState({ anchorElement });
    }

    close({ keepFocus = true } = {}) {
        if (this.state.isOpen) {
            this.setState({ isOpen: false });
            this.deregisterHandlers();

            // restore focus
            if (keepFocus && this.previouslyFocusedNode) {
                this.previouslyFocusedNode.focus();
                this.previouslyFocusedNode = null;
            }

            this.props.onClose();
        }
    }

    isOpen() {
        return this.state.isOpen;
    }

    disableTransition() {

    }

    enableTransition() {

    }

    render() {
        const { children, innerRef, opened, targetOrigin, ...other } = this.props;
        const { placement } = this.state;

        const props = {
            ...other,
            innerRef: c => {
                this.root = c;
                innerRef(c);
            },
            opened,
            origin: targetOrigin.value,
            placement,
            tabIndex: -1,
        };

        return (
            <OpenableOverlayElement {...props}>
                {children}
            </OpenableOverlayElement>
        );
    }
}

export default ClickAway(OpenableOverlay);

function getTargetPosition(el) {
    return {
        vertical: {
            top: 0,
            center: el.offsetHeight / 2,
            bottom: el.offsetHeight,
        },
        horizontal: {
            left: 0,
            center: el.offsetWidth / 2,
            right: el.offsetWidth,
        },
    };
}

function getElementTop(element) {
    let location = 0;
    let node = element;
    if (node.offsetParent) {
        do {
            location += node.offsetTop;
            node = node.offsetParent;
        } while (node);
    }

    return location >= 0 ? location : 0;
}

function getElementLeft(element) {
    let location = 0;
    let node = element;
    if (node.offsetParent) {
        do {
            location += node.offsetLeft;
            node = node.offsetParent;
        } while (node);
    }

    return location >= 0 ? location : 0;
}