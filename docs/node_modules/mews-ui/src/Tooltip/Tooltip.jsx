import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import Portal from '../Hoc/Portal';
import { noop } from '../utils/func';
import { addEventListenerOnTransitionEnded, removeEventListenerOnTransitionEnded } from '../utils/events';
import Position from './Position';
import { TooltipElement, TooltipContentElement } from './style';

export default ComposedComponent => class Tooltip extends Component {
    static propTypes = {
        children: pt.node,
        onClick: pt.func,
        onMouseEnter: pt.func,
        onMouseLeave: pt.func,
        tooltip: pt.node,
        tooltipDelay: pt.number,
        tooltipHideOnClick: pt.bool,
        tooltipPosition: pt.instanceOf(Position),
        tooltipShowOnClick: pt.bool,
    };

    static defaultProps = {
        delay: 0,
        onClick: noop,
        onMouseEnter: noop,
        onMouseLeave: noop,
        tooltipHideOnClick: true,
        tooltipPosition: Position.Vertical,
        tooltipShowOnClick: false,
    };

    state = {};

    componentWillUnmount() {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }

        if (this.tooltipElement) {
            removeEventListenerOnTransitionEnded(this.tooltipElement, this.handleTransitionEnd);
        }
    }

    activate({ top, left, position }) {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }

        this.setState({ visible: true, position });

        this.timeout = setTimeout(() => {
            this.setState({ active: true, top, left });
        }, this.props.tooltipDelay);
    }

    deactivate() {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }

        if (this.state.active) {
            addEventListenerOnTransitionEnded(this.tooltipElement, this.handleTransitionEnd);
            this.setState({ active: false });
        } else if (this.state.visible) {
            this.setState({ visible: false });
        }
    }

    getPosition(element) {
        const { tooltipPosition } = this.props;

        if (tooltipPosition === Position.Horizontal) {
            const origin = element.getBoundingClientRect();
            const { width: viewportWidth } = getViewport();
            const toRight = origin.left < ((viewportWidth / 2) - (origin.width / 2));
            return toRight ? Position.Right : Position.Left;
        } else if (tooltipPosition === Position.Vertical) {
            const origin = element.getBoundingClientRect();
            const { height: viewportHeight } = getViewport();
            const toBottom = origin.top < ((viewportHeight / 2) - (origin.height / 2));
            return toBottom ? Position.Bottom : Position.Top;
        }

        return tooltipPosition;
    }

    calculatePosition(element) {
        const position = this.getPosition(element);
        const { top, left, height, width } = element.getBoundingClientRect();
        const xOffset = window.scrollX || window.pageXOffset;
        const yOffset = window.scrollY || window.pageYOffset;

        if (position === Position.Bottom) {
            return {
                top: top + height + yOffset,
                left: left + (width / 2) + xOffset,
                position,
            };
        } else if (position === Position.Top) {
            return {
                top: top + yOffset,
                left: left + (width / 2) + xOffset,
                position,
            };
        } else if (position === Position.Left) {
            return {
                top: top + (height / 2) + yOffset,
                left: left + xOffset,
                position,
            };
        } else if (position === Position.Right) {
            return {
                top: top + (height / 2) + yOffset,
                left: left + width + xOffset,
                position,
            };
        }
    }

    handleClick = e => {
        if (this.props.tooltipHideOnClick && this.state.active) {
            this.deactivate();
        }

        if (this.props.tooltipShowOnClick && !this.state.active) {
            const position = this.calculatePosition(e.currentTarget);
            this.activate(position);
        }

        this.props.onClick(e);
    };

    handleMouseEnter = e => {
        const position = this.calculatePosition(e.currentTarget);
        this.activate(position);
        this.props.onMouseEnter(e);
    };

    handleMouseLeave = e => {
        this.deactivate();
        this.props.onMouseLeave(e);
    };

    handleTransformEnd = () => {
        this.setState({ visible: false });
    };

    render() {
        const { active, left, top, position, visible } = this.state;
        const { children, tooltip, ...other } = this.props;

        delete other.tooltipDelay;
        delete other.tooltipHideOnClick;
        delete other.tooltipPosition;
        delete other.tooltipShowOnClick;

        const componentProps = {
            ...other,
            onClick: this.handleClick,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
        };

        let tooltipElement;
        if (visible) {
            const tooltipProps = {
                active,
                top,
                left,
                position,
                innerRef: c => (this.tooltipElement = c),
            };

            tooltipElement = (
                <Portal>
                    <TooltipElement {...tooltipProps}>
                        <TooltipContentElement>{tooltip}</TooltipContentElement>
                    </TooltipElement>
                </Portal>
            );
        }

        return (
            <ComposedComponent {...componentProps}>
                {children}
                {tooltipElement}
            </ComposedComponent>
        );
    }
};

function getViewport() {
    return {
        height: window.innerHeight || document.documentElement.offsetHeight,
        width: window.innerWidth || document.documentElement.offsetWidth,
    };
}
