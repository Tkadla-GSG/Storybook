import _ from 'lodash';
import React from 'react';
import { PropTypes as pt } from 'prop-types';
import ReactDOM from 'react-dom';

import * as events from '../utils/events';
import { RIPPLE_WRAPPER_CLASSNAME, RippleElement, RippleWrapper } from './style';

const defaults = {
    centered: false,
    className: '',
    multiple: true,
    spread: 2,
};

const Ripple = (options = {}) => {
    const {
        centered: defaultCentered,
        className: defaultClassName,
        multiple: defaultMultiple,
        spread: defaultSpread,
        ...props
    } = { ...defaults, ...options };

    return Component => React.createClass({
        propTypes: {
            disabled: pt.bool,
            onMouseDown: pt.func,
            onRippleEnded: pt.func,
            onTouchStart: pt.func,
            ripple: pt.bool,
            rippleCentered: pt.bool,
            rippleClassName: pt.string,
            rippleMultiple: pt.bool,
            rippleSpread: pt.number,
        },

        getDefaultProps() {
            return {
                disabled: false,
                ripple: true,
                rippleCentered: defaultCentered,
                rippleClassName: defaultClassName,
                rippleMultiple: defaultMultiple,
                rippleSpread: defaultSpread,
            };
        },

        getInitialState() {
            return {
                ripples: {},
            };
        },

        componentDidMount() {
            this.rippleNodes = {};
        },

        componentDidUpdate(prevProps, prevState) {
            if (_.size(prevState.ripples) < _.size(this.state.ripples)) {
                this.addRippleRemoveEventListener(this.getLastKey());
            }
        },

        componentWillUnmount() {
            _.each(this.state.ripples, r => r.endRipple());
        },

        getDescriptor(x, y) {
            // You can't get a ref to wrapped component
            const { left, top, height, width } = ReactDOM.findDOMNode(this).getBoundingClientRect(); // eslint-disable-line react/no-find-dom-node
            const { rippleCentered: centered, rippleSpread: spread } = this.props;
            return {
                left: centered ? 0 : x - left - (width / 2),
                top: centered ? 0 : y - top - (height / 2),
                width: width * spread,
            };
        },

        getNextKey() {
            this.currentCount = this.currentCount ? this.currentCount + 1 : 1;
            return this.getKey(this.currentCount);
        },

        getLastKey() {
            return this.getKey(this.currentCount);
        },

        getKey(id) {
            return `ripple${id}`;
        },

        animateRipple(x, y, isTouch) {
            if (this.rippleShouldTrigger(isTouch)) {
                const { top, left, width } = this.getDescriptor(x, y);
                const noRipplesActive = _.isEmpty(this.state.ripples);

                const key = this.props.rippleMultiple || noRipplesActive ? this.getNextKey() : this.getLastKey();

                const endRipple = this.addRippleDeactivateEventListener(isTouch, key);

                const initialState = { active: false, restarting: true, top, left, width, endRipple };
                const runningState = { active: true, restarting: false };

                const ripples = { ...this.state.ripples, [key]: initialState };

                this.setState({ ripples }, () => {
                    this.rippleNodes[key].offsetWidth; // eslint-disable-line no-unused-expressions

                    this.setState({
                        ripples: {
                            ...this.state.ripples,
                            [key]: Object.assign({}, this.state.ripples[key], runningState),
                        },
                    });
                });
            }
        },

        rippleShouldTrigger(isTouch) {
            const shouldStart = isTouch ? true : !this.touchCache;
            this.touchCache = isTouch;
            return shouldStart;
        },

        addRippleDeactivateEventListener(isTouch, rippleKey) {
            const eventType = isTouch ? 'touchend' : 'mouseup';
            const endRipple = this.createRippleDeactivateCallback(eventType, rippleKey);
            document.addEventListener(eventType, endRipple);
            return endRipple;
        },

        createRippleDeactivateCallback(eventType, rippleKey) {
            const endRipple = () => {
                document.removeEventListener(eventType, endRipple);
                this.setState({
                    ripples: {
                        ...this.state.ripples,
                        [rippleKey]: _.assign({}, this.state.ripples[rippleKey], { active: false }),
                    },
                });
            };

            return endRipple;
        },

        addRippleRemoveEventListener(rippleKey) {
            const onOpacityEnd = e => {
                if (e.propertyName === 'opacity') {
                    if (this.props.onRippleEnded) {
                        this.props.onRippleEnded(e);
                    }

                    events.removeEventListenerOnTransitionEnded(this.rippleNodes[rippleKey], onOpacityEnd);
                    this.setState({ ripples: _.unset(this.state.ripples, rippleKey) });
                }
            };

            events.addEventListenerOnTransitionEnded(this.rippleNodes[rippleKey], onOpacityEnd);
        },

        handleMouseDown(event) {
            if (this.props.onMouseDown) {
                this.props.onMouseDown(event);
            }

            if (!this.props.disabled) {
                const { x, y } = events.getMousePosition(event);
                this.animateRipple(x, y, false);
            }
        },

        handleTouchStart(event) {
            if (this.props.onTouchStart) {
                this.props.onTouchStart(event);
            }

            if (!this.props.disabled) {
                const { x, y } = events.getTouchPosition(event);
                this.animateRipple(x, y, true);
            }
        },

        renderRipple(key, className, rippleProps) {
            return (
                <RippleWrapper key={key} className={RIPPLE_WRAPPER_CLASSNAME} {...props}>
                    <RippleElement className={className} innerRef={c => (this.rippleNodes[key] = c)} {...rippleProps} />
                </RippleWrapper>
            );
        },

        render() {
            const { ripples } = this.state;
            const { onRippleEnded, rippleCentered, rippleMultiple, rippleSpread, children, innerRef, ripple, rippleClassName, ...other } = this.props;

            if (!ripple) {
                return <Component {...other} ref={innerRef}>{children}</Component>;
            }

            return (
                <Component {...other} ref={innerRef} onMouseDown={this.handleMouseDown} onTouchStart={this.handleTouchStart}>
                    {children}
                    {_.map(ripples, (r, key) => this.renderRipple(key, rippleClassName, r))}
                </Component>
            );
        },
    });
};

export default Ripple;
