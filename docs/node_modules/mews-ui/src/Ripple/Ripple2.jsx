import _ from 'lodash';
import React from 'react';
import ReactDOM from 'react-dom';
import styled, { css, keyframes } from 'styled-components';

import { ANIMATION_CURVE_FAST_OUT_SLOW_IN } from '../variables';
import { getMousePosition, getTouchPosition } from '../utils/events';

const rippleFgOpacityOut = keyframes`
    from {
        opacity: 1;
        animation-timing-function: linear;
    }
    to {
        opacity: 0;
    }
`;

const rippleFgRadiusIn = keyframes`
    from {
        transform: translate(var(--ripple-fg-translate-start)) scale(1);
        animation-timing-function: ${ANIMATION_CURVE_FAST_OUT_SLOW_IN};
    }
    to {
        transform: translate(var(--ripple-fg-translate-end)) scale(var(--ripple-fg-scale));
    }
`;
/*
const k = keyframes`
    @keyframes mdc-ripple-fg-unbounded-opacity-deactivate {
    from {
        opacity: 1; }
    to {
        opacity: 0; } }

    @keyframes mdc-ripple-fg-unbounded-transform-deactivate {
    from {
        transform: var(--mdc-ripple-fg-approx-xf); }
    to {
        transform: scale(var(--mdc-ripple-fg-scale)); } }
`;
*/

const RADIUS = '100%';

const s = css`
    will-change: transition, opacity;
    -webkit-tap-highlight-color: transparent;

    position: relative;
    overflow: hidden;
    outline: none;

    &::before {
        background-color: rgba(0, 0, 0, 0.06);
        position: absolute;
        top: calc(50% - ${RADIUS});
        left: calc(50% - ${RADIUS});
        width: calc(${RADIUS} * 2);
        height: calc(${RADIUS} * 2);
        transition: opacity 250ms linear;
        transform: scale(var(--ripple-fg-scale, 0));
        border-radius: 50%;
        opacity: 0;
        pointer-events: none;
        content: '';
    }

    ${props => props.rippleBgActive && css`
        &::before {
            opacity: .99999;
        }

        &:active::before {

        }
    `}

    &::after {
        background-color: rgba(0, 0, 0, 0.06);
        position: absolute;
        top: 0;
        left: 0;
        width: var(--ripple-fg-size, 0);
        height: var(--ripple-fg-size, 0);
        transform: scale(0);
        transform-origin: center center;
        border-radius: 50%;
        opacity: 0;
        pointer-events: none;
        content: '';

        ${props => props.rippleFgActive && css`
            animation-fill-mode: forwards;
            animation: 300ms ${rippleFgRadiusIn}, 400ms ${rippleFgOpacityOut};
        `}
    }
`;

const INITIAL_ORIGIN_SCALE = 0.6;
const PADDING = 10;

const DEACTIVATION_ACTIVATION_PAIRS = {
    mouseup: 'mousedown',
    pointerup: 'pointerdown',
    touchend: 'touchstart',
    keyup: 'keydown',
    blur: 'focus',
};

const LISTENERS = [
    { activate: 'touchstart', deactivate: 'touchend' },
    { activate: 'mousedown', deactivate: 'mouseup' },
    { activate: 'keydown', deactivate: 'keyup' },
    { focus: 'focus', blur: 'blur' },
];

const Ripple = ({ unbounded = false } = {}) => Component => {
    const RippledComponent = styled(Component)`
        ${s}
    `;

    return React.createClass({
        getDefaultProps() {
            return {
                onMouseDown: _.noop,
                onMouseUp: _.noop,
                onTouchStart: _.noop,
                onTouchEnd: _.noop,
                onKeyDown: _.noop,
                onKeyUp: _.noop,
                onFocus: _.noop,
                onBlur: _.noop,
            };
        },

        getInitialState() {
            return {
            };
        },

        handleLayout() {
            if (this.layoutFrame) {
                cancelAnimationFrame(this.layoutFrame);
            }

            this.layoutFrame = requestAnimationFrame(() => {
                this.layout();
                this.layoutFrame = null;
            });
        },

        componentDidMount() {
            const adapter = ReactDOM.findDOMNode(this);

            window.addEventListener('resize', this.handleLayout);
            this.layout();

            this.cancelBgBounded = _.noop;
            this.cancelFgBounded = _.noop;
            this.cancelFgUnbounded = _.noop;
        },

        layout() {
            this.frame = this.getAdapter().getBoundingClientRect();
            const { height, width } = this.frame;

            const maxDimension = Math.max(width, height);
            const surfaceDiameter = Math.sqrt((width ** 2) + (height ** 2));

            const initialSize = maxDimension * INITIAL_ORIGIN_SCALE;

            const maxRadius = surfaceDiameter + PADDING;
            const fgScale = maxRadius / initialSize;
            const duration = 1000 * Math.sqrt(maxRadius / 1024);

            this.ripple = {
                surfaceWidth: width,
                surfaceHeight: height,
                rippleFgSize: initialSize,
                fgScale,
                fgUnboundedDuration: duration,
            };

            this.rippleFgSize = initialSize;

            this.updateCssVariable('--ripple-surface-width', `${width}px`);
            this.updateCssVariable('--ripple-surface-height', `${height}px`);
            this.updateCssVariable('--ripple-fg-size', `${initialSize}px`);
            this.updateCssVariable('--ripple-fg-unbounded-transform-duration', `${duration}ms`);
            this.updateCssVariable('--ripple-fg-scale', fgScale);
        },

        updateCssVariable(name, value) {
            this.getAdapter().style.setProperty(name, value);
        },

        getAdapter() {
            let adapter;
            if (!adapter) {
                adapter = ReactDOM.findDOMNode(this);
            }
            return adapter;
        },

        componentWillUnmount() {
            window.removeEventListener('resize', this.handleLayout);
            // remove css vars
        },

        handleMouseDown(e) {
            this.props.onMouseDown(e);
            this.activate(e);
        },

        handleMouseUp(e) {
            this.props.onMouseUp(e);
            this.deactivate(e);
        },

        handleTouchStart(e) {
            this.props.onTouchStart(e);
            this.activate(e);
        },

        handleTouchEnd(e) {
            this.props.onTouchEnd(e);
            this.deactivate(e);
        },

        handleKeyDown(e) {
            this.props.onKeyDown(e);
            this.activate(e);
        },

        handleKeyUp(e) {
            this.props.onKeyUp(e);
            this.deactivate(e);
        },

        handleFocus(e) {
            this.props.onFocus(e);
            this.setState({ rippleBgActive: true });
        },

        handleBlur(e) {
            this.props.onBlur(e);
            this.setState({ rippleBgActive: false });
        },

        activate(e) {
            if (this.state.isActivated) {
                return;
            }

            e.persist();
            const isActivated = true;
            const isProgrammatic = e === null;
            const wasActivatedByPointer = isProgrammatic ? false : (e.type === 'mousedown' || e.type === 'touchstart');
            const activationStartTime = Date.now();

            requestAnimationFrame(() => {
                const wasElementMadeActive = (e && e.type === 'keydown') ? this.isSurfaceActive() : true;
                if (wasElementMadeActive) {
                    this.animateActivation();
                }
            });
        },

        animateActivation() {
            // canceling

            // bg active
            // if unbounded animate unbounded activation
        },

        deactivate(e) {
            if (!this.state.isActivated) {

            }

            // if programmatic
        },

        animateBoundedDeactivation(event, isPointerEvent) {
            let startPoint;
            if (isPointerEvent) {
                startPoint = getNormalizedEventCoords(
                    event,
                    { x: window.pageXOffset, y: window.pageYOffset },
                    this.getAdapter().getBoundingClientRect(),
                );
            } else {
                startPoint = {
                    x: this.frame.width / 2,
                    y: this.frame.height / 2,
                };
            }

            startPoint = {
                x: startPoint.x - (this.ripple.rippleFgSize / 2),
                y: startPoint.y - (this.ripple.rippleFgSize / 2),
            };

            const endPoint = {
                x: (this.frame.width / 2) - (this.ripple.rippleFgSize / 2),
                y: (this.frame.height / 2) - (this.ripple.rippleFgSize / 2),
            };

            this.setState({
                rippleFgActive: true,
            });

            this.updateCssVariable('--ripple-fg-translate-start', `${startPoint.x}px, ${startPoint.y}px`);
            this.updateCssVariable('--ripple-fg-translate-end', `${endPoint.x}px, ${endPoint.y}px`);

            this.cancelBgBounded = this.animate('transitionEnd', 'rippleBgBoundedActive');
            this.cancelFgBounded = this.animate('animationend', 'rippleFgBoundedActive');
        },

        animate(flag, endEvent) {
            const adapter = ReactDOM.findDOMNode(this);

            let cancelled = false;
            const cancel = () => {
                if (cancelled) {
                    return;
                }

                cancelled = true;
                this.setState({ [flag]: false });
                adapter.removeEventListener(endEvent, cancel);
            };
            this.setState({ [flag]: true });
            adapter.addEventListener(endEvent, cancel);
            return cancel;
        },

        render() {
            const { rippleFgActive, rippleBgActive } = this.state;

            const props = {
                ...this.props,
                onMouseDown: this.handleMouseDown,
                onMouseUp: this.handleMouseUp,
                onTouchStart: this.handleTouchStart,
                onTouchEnd: this.handleTouchEnd,
                onKeyDown: this.handleKeyDown,
                onKeyUp: this.handleKeyup,
                onFocus: this.handleFocus,
                onBlur: this.handleBlur,

                rippleFgActive,
                rippleBgActive,
            };

            return (
                <RippledComponent {...props} tabIndex={0} />
            );
        },
    });
};

export default Ripple;

function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    const { x, y } = pageOffset;
    const documentX = x + clientRect.left;
    const documentY = y + clientRect.top;

    let normalizedX;
    let normalizedY;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchend') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
}

function animateWithClass(rippleAdapter, cls, endEvent) {
    let cancelled = false;
    const cancel = () => {
        if (cancelled) {
            return;
        }
        cancelled = true;
        rippleAdapter.removeClass(cls);
        rippleAdapter.deregisterInteractionHandler(endEvent, cancel);
    };
    rippleAdapter.registerInteractionHandler(endEvent, cancel);
    rippleAdapter.addClass(cls);
    return cancel;
}
