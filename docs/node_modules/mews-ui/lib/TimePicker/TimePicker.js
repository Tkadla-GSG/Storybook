var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { noop } from '../utils/func';
import { TimePickerElement } from './style';
import ScrollableSelector from './ScrollableSelector';

export var AM = 'am';
export var PM = 'pm';

var SEPARATOR = ':';

var padValue = function padValue(value) {
    return _.padStart(value, 2, '0');
};
var replace12with0 = function replace12with0(value) {
    return value === 0 ? 12 : value;
};

var getValue = function getValue() {
    var decorate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (v) {
        return v;
    };
    return function (value) {
        return { value: value, text: decorate(value) };
    };
};

var VALUES_12 = _.times(12, getValue(replace12with0)); // value => ({ value, text: `${value}` }));
var VALUES_12_PADDED = _.times(12, getValue(function (v) {
    return padValue(replace12with0(v));
})); // value => ({ value, text: `${_.padStart(value, 2, '0')}` }));
var VALUES_24 = _.times(24, getValue()); // value => ({ value, text: `${value}` }));
var VALUES_24_PADDED = _.times(24, getValue(padValue)); // value => ({ value, text: `${_.padStart(value, 2, '0')}` }));
var VALUES_60 = _.times(60, getValue(padValue)); // value => ({ value, text: `${_.padStart(value, 2, '0')}` }));

var TimePicker = function (_Component) {
    _inherits(TimePicker, _Component);

    function TimePicker(props) {
        _classCallCheck(this, TimePicker);

        var _this = _possibleConstructorReturn(this, (TimePicker.__proto__ || Object.getPrototypeOf(TimePicker)).call(this, props));

        _initialiseProps.call(_this);

        var has24HourFormat = props.getTimeService().has24HourFormat();
        var shouldPadHours = props.getTimeService().shouldPadHours();
        var time = props.time || props.getTimeService().getDefaultTime();
        var meridiem = props.getTimeService().getHours(time) > 11 ? PM : AM;

        _this.state = { time: time, has24HourFormat: has24HourFormat, shouldPadHours: shouldPadHours, meridiem: meridiem };
        return _this;
    }

    _createClass(TimePicker, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.time && !this.props.getTimeService().isTimeEqual(nextProps.time, this.state.time)) {
                var meridiem = this.props.getTimeService().getHours(nextProps.time) > 11 ? PM : AM;
                this.setState({
                    time: nextProps.time,
                    meridiem: meridiem
                });
            }
        }
    }, {
        key: 'renderSecondsSelector',
        value: function renderSecondsSelector() {
            var getTimeService = this.props.getTimeService;
            var time = this.state.time;


            var seconds = getTimeService().getSeconds(time);
            var props = {
                onChange: this.handleSecondsChange,
                values: VALUES_60,
                value: seconds
            };

            return React.createElement(ScrollableSelector, props);
        }
    }, {
        key: 'renderMeridiemSelector',
        value: function renderMeridiemSelector() {
            var meridiem = this.state.meridiem;

            var _props$getTimeService = this.props.getTimeService().getMeridiemLabels(),
                _props$getTimeService2 = _slicedToArray(_props$getTimeService, 2),
                amLabel = _props$getTimeService2[0],
                pmLabel = _props$getTimeService2[1];

            var props = {
                values: [{ value: AM, text: amLabel }, { value: PM, text: pmLabel }],
                value: meridiem,
                onChange: this.handleMeridiemChange
            };

            return React.createElement(ScrollableSelector, props);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                getTimeService = _props.getTimeService,
                showSeconds = _props.showSeconds;
            var _state = this.state,
                has24HourFormat = _state.has24HourFormat,
                shouldPadHours = _state.shouldPadHours,
                time = _state.time,
                meridiem = _state.meridiem;


            var hours = getTimeService().getHours(time) - (!has24HourFormat && meridiem === PM ? 12 : 0);
            var minutes = getTimeService().getMinutes(time);

            var hourValues = void 0;
            if (has24HourFormat) {
                hourValues = shouldPadHours ? VALUES_24_PADDED : VALUES_24;
            } else {
                hourValues = shouldPadHours ? VALUES_12_PADDED : VALUES_12;
            }

            var hoursSelectorProps = {
                afterLabel: SEPARATOR,
                onChange: this.handleHoursChange,
                value: hours,
                values: hourValues
            };

            var minutesSelectorProps = {
                afterLabel: showSeconds && SEPARATOR,
                onChange: this.handleMinutesChange,
                value: minutes,
                values: VALUES_60
            };

            return React.createElement(
                TimePickerElement,
                null,
                React.createElement(ScrollableSelector, hoursSelectorProps),
                React.createElement(ScrollableSelector, minutesSelectorProps),
                showSeconds && this.renderSecondsSelector(),
                !has24HourFormat && this.renderMeridiemSelector()
            );
        }
    }]);

    return TimePicker;
}(Component);

TimePicker.propTypes = {
    onTimeChange: pt.func,
    time: pt.any,
    amLabel: pt.node,
    pmLabel: pt.node,
    hoursLabel: pt.node,
    minutesLabel: pt.node,
    getTimeService: pt.func.isRequired,
    showSeconds: pt.bool
};
TimePicker.defaultProps = {
    onTimeChange: noop
};

var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.handleHoursChange = function (hours) {
        var getTimeService = _this2.props.getTimeService;
        var _state2 = _this2.state,
            has24HourFormat = _state2.has24HourFormat,
            time = _state2.time,
            meridiem = _state2.meridiem;

        var realHours = hours + (!has24HourFormat && meridiem === PM ? 12 : 0);

        var currentHours = getTimeService().getHours(time);
        if (currentHours === hours) {
            return;
        }

        var diff = realHours - currentHours;
        var newTime = getTimeService().addHours(time, diff);
        _this2.setState({ time: newTime });

        _this2.props.onTimeChange(newTime);
    };

    this.handleMinutesChange = function (minutes) {
        var getTimeService = _this2.props.getTimeService;
        var time = _this2.state.time;


        var currentMinutes = getTimeService().getMinutes(time);
        if (currentMinutes === minutes) {
            return;
        }

        var diff = minutes - currentMinutes;
        var newTime = getTimeService().addMinutes(time, diff);
        _this2.setState({ time: newTime });

        _this2.props.onTimeChange(newTime);
    };

    this.handleSecondsChange = function (seconds) {
        var getTimeService = _this2.props.getTimeService;
        var time = _this2.state.time;


        var currentSeconds = getTimeService().getSeconds(time);
        if (currentSeconds === seconds) {
            return;
        }

        var diff = seconds - currentSeconds;
        var newTime = getTimeService().addSeconds(time, diff);
        _this2.setState({ time: newTime });

        _this2.props.onTimeChange(newTime);
    };

    this.handleMeridiemChange = function (meridiem) {
        var getTimeService = _this2.props.getTimeService;
        var time = _this2.state.time;


        var diff = meridiem === PM ? 12 : -12;
        var newTime = getTimeService().addHours(time, diff);

        _this2.setState({
            meridiem: meridiem,
            time: newTime
        });

        _this2.props.onTimeChange(newTime);
    };
};

export default TimePicker;