var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _templateObject = _taggedTemplateLiteral(['\n    from {\n        opacity: 1;\n        animation-timing-function: linear;\n    }\n    to {\n        opacity: 0;\n    }\n'], ['\n    from {\n        opacity: 1;\n        animation-timing-function: linear;\n    }\n    to {\n        opacity: 0;\n    }\n']),
    _templateObject2 = _taggedTemplateLiteral(['\n    from {\n        transform: translate(var(--ripple-fg-translate-start)) scale(1);\n        animation-timing-function: ', ';\n    }\n    to {\n        transform: translate(var(--ripple-fg-translate-end)) scale(var(--ripple-fg-scale));\n    }\n'], ['\n    from {\n        transform: translate(var(--ripple-fg-translate-start)) scale(1);\n        animation-timing-function: ', ';\n    }\n    to {\n        transform: translate(var(--ripple-fg-translate-end)) scale(var(--ripple-fg-scale));\n    }\n']),
    _templateObject3 = _taggedTemplateLiteral(['\n    will-change: transition, opacity;\n    -webkit-tap-highlight-color: transparent;\n\n    position: relative;\n    overflow: hidden;\n    outline: none;\n\n    &::before {\n        background-color: rgba(0, 0, 0, 0.06);\n        position: absolute;\n        top: calc(50% - ', ');\n        left: calc(50% - ', ');\n        width: calc(', ' * 2);\n        height: calc(', ' * 2);\n        transition: opacity 250ms linear;\n        transform: scale(var(--ripple-fg-scale, 0));\n        border-radius: 50%;\n        opacity: 0;\n        pointer-events: none;\n        content: \'\';\n    }\n\n    ', '\n\n    &::after {\n        background-color: rgba(0, 0, 0, 0.06);\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: var(--ripple-fg-size, 0);\n        height: var(--ripple-fg-size, 0);\n        transform: scale(0);\n        transform-origin: center center;\n        border-radius: 50%;\n        opacity: 0;\n        pointer-events: none;\n        content: \'\';\n\n        ', '\n    }\n'], ['\n    will-change: transition, opacity;\n    -webkit-tap-highlight-color: transparent;\n\n    position: relative;\n    overflow: hidden;\n    outline: none;\n\n    &::before {\n        background-color: rgba(0, 0, 0, 0.06);\n        position: absolute;\n        top: calc(50% - ', ');\n        left: calc(50% - ', ');\n        width: calc(', ' * 2);\n        height: calc(', ' * 2);\n        transition: opacity 250ms linear;\n        transform: scale(var(--ripple-fg-scale, 0));\n        border-radius: 50%;\n        opacity: 0;\n        pointer-events: none;\n        content: \'\';\n    }\n\n    ', '\n\n    &::after {\n        background-color: rgba(0, 0, 0, 0.06);\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: var(--ripple-fg-size, 0);\n        height: var(--ripple-fg-size, 0);\n        transform: scale(0);\n        transform-origin: center center;\n        border-radius: 50%;\n        opacity: 0;\n        pointer-events: none;\n        content: \'\';\n\n        ', '\n    }\n']),
    _templateObject4 = _taggedTemplateLiteral(['\n        &::before {\n            opacity: .99999;\n        }\n\n        &:active::before {\n\n        }\n    '], ['\n        &::before {\n            opacity: .99999;\n        }\n\n        &:active::before {\n\n        }\n    ']),
    _templateObject5 = _taggedTemplateLiteral(['\n            animation-fill-mode: forwards;\n            animation: 300ms ', ', 400ms ', ';\n        '], ['\n            animation-fill-mode: forwards;\n            animation: 300ms ', ', 400ms ', ';\n        ']),
    _templateObject6 = _taggedTemplateLiteral(['\n        ', '\n    '], ['\n        ', '\n    ']);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import _ from 'lodash';
import React from 'react';
import ReactDOM from 'react-dom';
import styled, { css, keyframes } from 'styled-components';

import { ANIMATION_CURVE_FAST_OUT_SLOW_IN } from '../variables';
import { getMousePosition, getTouchPosition } from '../utils/events';

var rippleFgOpacityOut = keyframes(_templateObject);

var rippleFgRadiusIn = keyframes(_templateObject2, ANIMATION_CURVE_FAST_OUT_SLOW_IN);
/*
const k = keyframes`
    @keyframes mdc-ripple-fg-unbounded-opacity-deactivate {
    from {
        opacity: 1; }
    to {
        opacity: 0; } }

    @keyframes mdc-ripple-fg-unbounded-transform-deactivate {
    from {
        transform: var(--mdc-ripple-fg-approx-xf); }
    to {
        transform: scale(var(--mdc-ripple-fg-scale)); } }
`;
*/

var RADIUS = '100%';

var s = css(_templateObject3, RADIUS, RADIUS, RADIUS, RADIUS, function (props) {
    return props.rippleBgActive && css(_templateObject4);
}, function (props) {
    return props.rippleFgActive && css(_templateObject5, rippleFgRadiusIn, rippleFgOpacityOut);
});

var INITIAL_ORIGIN_SCALE = 0.6;
var PADDING = 10;

var DEACTIVATION_ACTIVATION_PAIRS = {
    mouseup: 'mousedown',
    pointerup: 'pointerdown',
    touchend: 'touchstart',
    keyup: 'keydown',
    blur: 'focus'
};

var LISTENERS = [{ activate: 'touchstart', deactivate: 'touchend' }, { activate: 'mousedown', deactivate: 'mouseup' }, { activate: 'keydown', deactivate: 'keyup' }, { focus: 'focus', blur: 'blur' }];

var Ripple = function Ripple() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$unbounded = _ref.unbounded,
        unbounded = _ref$unbounded === undefined ? false : _ref$unbounded;

    return function (Component) {
        var RippledComponent = styled(Component)(_templateObject6, s);

        return React.createClass({
            getDefaultProps: function getDefaultProps() {
                return {
                    onMouseDown: _.noop,
                    onMouseUp: _.noop,
                    onTouchStart: _.noop,
                    onTouchEnd: _.noop,
                    onKeyDown: _.noop,
                    onKeyUp: _.noop,
                    onFocus: _.noop,
                    onBlur: _.noop
                };
            },
            getInitialState: function getInitialState() {
                return {};
            },
            handleLayout: function handleLayout() {
                var _this = this;

                if (this.layoutFrame) {
                    cancelAnimationFrame(this.layoutFrame);
                }

                this.layoutFrame = requestAnimationFrame(function () {
                    _this.layout();
                    _this.layoutFrame = null;
                });
            },
            componentDidMount: function componentDidMount() {
                var adapter = ReactDOM.findDOMNode(this);

                window.addEventListener('resize', this.handleLayout);
                this.layout();

                this.cancelBgBounded = _.noop;
                this.cancelFgBounded = _.noop;
                this.cancelFgUnbounded = _.noop;
            },
            layout: function layout() {
                this.frame = this.getAdapter().getBoundingClientRect();
                var _frame = this.frame,
                    height = _frame.height,
                    width = _frame.width;


                var maxDimension = Math.max(width, height);
                var surfaceDiameter = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));

                var initialSize = maxDimension * INITIAL_ORIGIN_SCALE;

                var maxRadius = surfaceDiameter + PADDING;
                var fgScale = maxRadius / initialSize;
                var duration = 1000 * Math.sqrt(maxRadius / 1024);

                this.ripple = {
                    surfaceWidth: width,
                    surfaceHeight: height,
                    rippleFgSize: initialSize,
                    fgScale: fgScale,
                    fgUnboundedDuration: duration
                };

                this.rippleFgSize = initialSize;

                this.updateCssVariable('--ripple-surface-width', width + 'px');
                this.updateCssVariable('--ripple-surface-height', height + 'px');
                this.updateCssVariable('--ripple-fg-size', initialSize + 'px');
                this.updateCssVariable('--ripple-fg-unbounded-transform-duration', duration + 'ms');
                this.updateCssVariable('--ripple-fg-scale', fgScale);
            },
            updateCssVariable: function updateCssVariable(name, value) {
                this.getAdapter().style.setProperty(name, value);
            },
            getAdapter: function getAdapter() {
                var adapter = void 0;
                if (!adapter) {
                    adapter = ReactDOM.findDOMNode(this);
                }
                return adapter;
            },
            componentWillUnmount: function componentWillUnmount() {
                window.removeEventListener('resize', this.handleLayout);
                // remove css vars
            },
            handleMouseDown: function handleMouseDown(e) {
                this.props.onMouseDown(e);
                this.activate(e);
            },
            handleMouseUp: function handleMouseUp(e) {
                this.props.onMouseUp(e);
                this.deactivate(e);
            },
            handleTouchStart: function handleTouchStart(e) {
                this.props.onTouchStart(e);
                this.activate(e);
            },
            handleTouchEnd: function handleTouchEnd(e) {
                this.props.onTouchEnd(e);
                this.deactivate(e);
            },
            handleKeyDown: function handleKeyDown(e) {
                this.props.onKeyDown(e);
                this.activate(e);
            },
            handleKeyUp: function handleKeyUp(e) {
                this.props.onKeyUp(e);
                this.deactivate(e);
            },
            handleFocus: function handleFocus(e) {
                this.props.onFocus(e);
                this.setState({ rippleBgActive: true });
            },
            handleBlur: function handleBlur(e) {
                this.props.onBlur(e);
                this.setState({ rippleBgActive: false });
            },
            activate: function activate(e) {
                var _this2 = this;

                if (this.state.isActivated) {
                    return;
                }

                e.persist();
                var isActivated = true;
                var isProgrammatic = e === null;
                var wasActivatedByPointer = isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart';
                var activationStartTime = Date.now();

                requestAnimationFrame(function () {
                    var wasElementMadeActive = e && e.type === 'keydown' ? _this2.isSurfaceActive() : true;
                    if (wasElementMadeActive) {
                        _this2.animateActivation();
                    }
                });
            },
            animateActivation: function animateActivation() {
                // canceling

                // bg active
                // if unbounded animate unbounded activation
            },
            deactivate: function deactivate(e) {
                if (!this.state.isActivated) {}

                // if programmatic
            },
            animateBoundedDeactivation: function animateBoundedDeactivation(event, isPointerEvent) {
                var startPoint = void 0;
                if (isPointerEvent) {
                    startPoint = getNormalizedEventCoords(event, { x: window.pageXOffset, y: window.pageYOffset }, this.getAdapter().getBoundingClientRect());
                } else {
                    startPoint = {
                        x: this.frame.width / 2,
                        y: this.frame.height / 2
                    };
                }

                startPoint = {
                    x: startPoint.x - this.ripple.rippleFgSize / 2,
                    y: startPoint.y - this.ripple.rippleFgSize / 2
                };

                var endPoint = {
                    x: this.frame.width / 2 - this.ripple.rippleFgSize / 2,
                    y: this.frame.height / 2 - this.ripple.rippleFgSize / 2
                };

                this.setState({
                    rippleFgActive: true
                });

                this.updateCssVariable('--ripple-fg-translate-start', startPoint.x + 'px, ' + startPoint.y + 'px');
                this.updateCssVariable('--ripple-fg-translate-end', endPoint.x + 'px, ' + endPoint.y + 'px');

                this.cancelBgBounded = this.animate('transitionEnd', 'rippleBgBoundedActive');
                this.cancelFgBounded = this.animate('animationend', 'rippleFgBoundedActive');
            },
            animate: function animate(flag, endEvent) {
                var _this3 = this;

                var adapter = ReactDOM.findDOMNode(this);

                var cancelled = false;
                var cancel = function cancel() {
                    if (cancelled) {
                        return;
                    }

                    cancelled = true;
                    _this3.setState(_defineProperty({}, flag, false));
                    adapter.removeEventListener(endEvent, cancel);
                };
                this.setState(_defineProperty({}, flag, true));
                adapter.addEventListener(endEvent, cancel);
                return cancel;
            },
            render: function render() {
                var _state = this.state,
                    rippleFgActive = _state.rippleFgActive,
                    rippleBgActive = _state.rippleBgActive;


                var props = _extends({}, this.props, {
                    onMouseDown: this.handleMouseDown,
                    onMouseUp: this.handleMouseUp,
                    onTouchStart: this.handleTouchStart,
                    onTouchEnd: this.handleTouchEnd,
                    onKeyDown: this.handleKeyDown,
                    onKeyUp: this.handleKeyup,
                    onFocus: this.handleFocus,
                    onBlur: this.handleBlur,

                    rippleFgActive: rippleFgActive,
                    rippleBgActive: rippleBgActive
                });

                return React.createElement(RippledComponent, _extends({}, props, { tabIndex: 0 }));
            }
        });
    };
};

export default Ripple;

function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchend') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
}

function animateWithClass(rippleAdapter, cls, endEvent) {
    var cancelled = false;
    var cancel = function cancel() {
        if (cancelled) {
            return;
        }
        cancelled = true;
        rippleAdapter.removeClass(cls);
        rippleAdapter.deregisterInteractionHandler(endEvent, cancel);
    };
    rippleAdapter.registerInteractionHandler(endEvent, cancel);
    rippleAdapter.addClass(cls);
    return cancel;
}