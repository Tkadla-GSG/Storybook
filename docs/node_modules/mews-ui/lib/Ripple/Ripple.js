var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import _ from 'lodash';
import React from 'react';
import { PropTypes as pt } from 'prop-types';
import ReactDOM from 'react-dom';

import * as events from '../utils/events';
import { RIPPLE_WRAPPER_CLASSNAME, RippleElement, RippleWrapper } from './style';

var defaults = {
    centered: false,
    className: '',
    multiple: true,
    spread: 2
};

var Ripple = function Ripple() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _defaults$options = _extends({}, defaults, options),
        defaultCentered = _defaults$options.centered,
        defaultClassName = _defaults$options.className,
        defaultMultiple = _defaults$options.multiple,
        defaultSpread = _defaults$options.spread,
        props = _objectWithoutProperties(_defaults$options, ['centered', 'className', 'multiple', 'spread']);

    return function (Component) {
        return React.createClass({
            propTypes: {
                disabled: pt.bool,
                onMouseDown: pt.func,
                onRippleEnded: pt.func,
                onTouchStart: pt.func,
                ripple: pt.bool,
                rippleCentered: pt.bool,
                rippleClassName: pt.string,
                rippleMultiple: pt.bool,
                rippleSpread: pt.number
            },

            getDefaultProps: function getDefaultProps() {
                return {
                    disabled: false,
                    ripple: true,
                    rippleCentered: defaultCentered,
                    rippleClassName: defaultClassName,
                    rippleMultiple: defaultMultiple,
                    rippleSpread: defaultSpread
                };
            },
            getInitialState: function getInitialState() {
                return {
                    ripples: {}
                };
            },
            componentDidMount: function componentDidMount() {
                this.rippleNodes = {};
            },
            componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
                if (_.size(prevState.ripples) < _.size(this.state.ripples)) {
                    this.addRippleRemoveEventListener(this.getLastKey());
                }
            },
            componentWillUnmount: function componentWillUnmount() {
                _.each(this.state.ripples, function (r) {
                    return r.endRipple();
                });
            },
            getDescriptor: function getDescriptor(x, y) {
                // You can't get a ref to wrapped component
                var _ReactDOM$findDOMNode = ReactDOM.findDOMNode(this).getBoundingClientRect(),
                    left = _ReactDOM$findDOMNode.left,
                    top = _ReactDOM$findDOMNode.top,
                    height = _ReactDOM$findDOMNode.height,
                    width = _ReactDOM$findDOMNode.width; // eslint-disable-line react/no-find-dom-node


                var _props = this.props,
                    centered = _props.rippleCentered,
                    spread = _props.rippleSpread;

                return {
                    left: centered ? 0 : x - left - width / 2,
                    top: centered ? 0 : y - top - height / 2,
                    width: width * spread
                };
            },
            getNextKey: function getNextKey() {
                this.currentCount = this.currentCount ? this.currentCount + 1 : 1;
                return this.getKey(this.currentCount);
            },
            getLastKey: function getLastKey() {
                return this.getKey(this.currentCount);
            },
            getKey: function getKey(id) {
                return 'ripple' + id;
            },
            animateRipple: function animateRipple(x, y, isTouch) {
                var _this = this;

                if (this.rippleShouldTrigger(isTouch)) {
                    var _getDescriptor = this.getDescriptor(x, y),
                        top = _getDescriptor.top,
                        left = _getDescriptor.left,
                        width = _getDescriptor.width;

                    var noRipplesActive = _.isEmpty(this.state.ripples);

                    var key = this.props.rippleMultiple || noRipplesActive ? this.getNextKey() : this.getLastKey();

                    var endRipple = this.addRippleDeactivateEventListener(isTouch, key);

                    var initialState = { active: false, restarting: true, top: top, left: left, width: width, endRipple: endRipple };
                    var runningState = { active: true, restarting: false };

                    var ripples = _extends({}, this.state.ripples, _defineProperty({}, key, initialState));

                    this.setState({ ripples: ripples }, function () {
                        _this.rippleNodes[key].offsetWidth; // eslint-disable-line no-unused-expressions

                        _this.setState({
                            ripples: _extends({}, _this.state.ripples, _defineProperty({}, key, Object.assign({}, _this.state.ripples[key], runningState)))
                        });
                    });
                }
            },
            rippleShouldTrigger: function rippleShouldTrigger(isTouch) {
                var shouldStart = isTouch ? true : !this.touchCache;
                this.touchCache = isTouch;
                return shouldStart;
            },
            addRippleDeactivateEventListener: function addRippleDeactivateEventListener(isTouch, rippleKey) {
                var eventType = isTouch ? 'touchend' : 'mouseup';
                var endRipple = this.createRippleDeactivateCallback(eventType, rippleKey);
                document.addEventListener(eventType, endRipple);
                return endRipple;
            },
            createRippleDeactivateCallback: function createRippleDeactivateCallback(eventType, rippleKey) {
                var _this2 = this;

                var endRipple = function endRipple() {
                    document.removeEventListener(eventType, endRipple);
                    _this2.setState({
                        ripples: _extends({}, _this2.state.ripples, _defineProperty({}, rippleKey, _.assign({}, _this2.state.ripples[rippleKey], { active: false })))
                    });
                };

                return endRipple;
            },
            addRippleRemoveEventListener: function addRippleRemoveEventListener(rippleKey) {
                var _this3 = this;

                var onOpacityEnd = function onOpacityEnd(e) {
                    if (e.propertyName === 'opacity') {
                        if (_this3.props.onRippleEnded) {
                            _this3.props.onRippleEnded(e);
                        }

                        events.removeEventListenerOnTransitionEnded(_this3.rippleNodes[rippleKey], onOpacityEnd);
                        _this3.setState({ ripples: _.unset(_this3.state.ripples, rippleKey) });
                    }
                };

                events.addEventListenerOnTransitionEnded(this.rippleNodes[rippleKey], onOpacityEnd);
            },
            handleMouseDown: function handleMouseDown(event) {
                if (this.props.onMouseDown) {
                    this.props.onMouseDown(event);
                }

                if (!this.props.disabled) {
                    var _events$getMousePosit = events.getMousePosition(event),
                        x = _events$getMousePosit.x,
                        y = _events$getMousePosit.y;

                    this.animateRipple(x, y, false);
                }
            },
            handleTouchStart: function handleTouchStart(event) {
                if (this.props.onTouchStart) {
                    this.props.onTouchStart(event);
                }

                if (!this.props.disabled) {
                    var _events$getTouchPosit = events.getTouchPosition(event),
                        x = _events$getTouchPosit.x,
                        y = _events$getTouchPosit.y;

                    this.animateRipple(x, y, true);
                }
            },
            renderRipple: function renderRipple(key, className, rippleProps) {
                var _this4 = this;

                return React.createElement(
                    RippleWrapper,
                    _extends({ key: key, className: RIPPLE_WRAPPER_CLASSNAME }, props),
                    React.createElement(RippleElement, _extends({ className: className, innerRef: function innerRef(c) {
                            return _this4.rippleNodes[key] = c;
                        } }, rippleProps))
                );
            },
            render: function render() {
                var _this5 = this;

                var ripples = this.state.ripples;

                var _props2 = this.props,
                    onRippleEnded = _props2.onRippleEnded,
                    rippleCentered = _props2.rippleCentered,
                    rippleMultiple = _props2.rippleMultiple,
                    rippleSpread = _props2.rippleSpread,
                    children = _props2.children,
                    innerRef = _props2.innerRef,
                    ripple = _props2.ripple,
                    rippleClassName = _props2.rippleClassName,
                    other = _objectWithoutProperties(_props2, ['onRippleEnded', 'rippleCentered', 'rippleMultiple', 'rippleSpread', 'children', 'innerRef', 'ripple', 'rippleClassName']);

                if (!ripple) {
                    return React.createElement(
                        Component,
                        _extends({}, other, { ref: innerRef }),
                        children
                    );
                }

                return React.createElement(
                    Component,
                    _extends({}, other, { ref: innerRef, onMouseDown: this.handleMouseDown, onTouchStart: this.handleTouchStart }),
                    children,
                    _.map(ripples, function (r, key) {
                        return _this5.renderRipple(key, rippleClassName, r);
                    })
                );
            }
        });
    };
};

export default Ripple;