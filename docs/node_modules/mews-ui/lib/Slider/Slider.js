var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import _ from 'lodash';
import React, { Component, PropTypes as pt } from 'react';
import { KeyCode } from 'mews-js';
import { noop } from '../utils/func';
import { SliderElement, SliderTrackElement, KnobContainerElement, KnobElement, KnobFocusElement } from './style';

var Slider = function (_Component) {
    _inherits(Slider, _Component);

    function Slider(props) {
        _classCallCheck(this, Slider);

        var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props));

        _this.handleFocus = function () {
            if (_this.preventFocusState) {
                return;
            }

            _this.setState({ focused: true });
        };

        _this.handleBlur = function () {
            _this.preventFocusState = false;
            _this.setState({ focused: false });
        };

        _this.handleResize = function () {
            var rect = _this.sliderElement.getBoundingClientRect();
            var left = rect.left;

            var width = rect.width;
            if (!width) {
                width = _this.sliderElement.offsetWidth;
            }

            _this.setState({
                sliderLeft: left,
                sliderWidth: width
            });
        };

        _this.handleKeyDown = function (e) {
            var keyCode = KeyCode.getByValue(e.which);

            var delta = NaN;
            switch (keyCode) {
                case KeyCode.Left:
                    delta = -_this.props.step;
                    break;

                case KeyCode.Right:
                    delta = _this.props.step;
                    break;

                default:
                    break;
            }

            if (!_.isNaN(delta)) {
                e.preventDefault();
                _this.setValue(_this.state.value + delta);
            }
        };

        _this.handleWheel = function (e) {
            if (_this.props.disabled) {
                return;
            }

            var delta = (e.deltaY > 0 ? 1 : -1) * _this.props.step;
            _this.setValue(_this.state.value + delta);
        };

        _this.handleMouseDown = _this.createDownHandler('mousemove', 'mouseup');
        _this.handleTouchStart = _this.createDownHandler('touchmove', 'touchend', function (_ref) {
            var targetTouches = _ref.targetTouches;
            return targetTouches[0].pageX;
        });

        _this.state = {
            sliderLength: 0,
            sliderStart: 0,
            value: _this.normalizeValue(props.value)
        };
        return _this;
    }

    _createClass(Slider, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            window.addEventListener('resize', this.handleResize);
            this.handleResize();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.value && nextProps.value !== this.props.value) {
                var normalizedValue = this.normalizeValue(nextProps.value);
                this.setState({ value: normalizedValue });
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('resize', this.handleResize);
        }
    }, {
        key: 'setValueFromEvent',
        value: function setValueFromEvent(e, getPageX) {
            var pageX = getPageX(e);
            var value = this.computeValueFromPageX(pageX);
            this.setValue(value);
        }
    }, {
        key: 'setValue',
        value: function setValue(value) {
            if (value === this.state.value) {
                return;
            }

            var normalizedValue = this.normalizeValue(value);
            this.setState({ value: normalizedValue });
            this.props.onChange(normalizedValue);
        }
    }, {
        key: 'createDownHandler',
        value: function createDownHandler(moveEvent, upEvent) {
            var _this2 = this;

            var getPageX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (_ref2) {
                var pageX = _ref2.pageX;
                return pageX;
            };

            var moveHandler = function moveHandler(e) {
                e.preventDefault();
                _this2.setValueFromEvent(e, getPageX);
            };

            var upHandler = function upHandler() {
                _this2.setState({ active: false });

                document.body.removeEventListener(moveEvent, moveHandler);
                document.body.removeEventListener(upEvent, upHandler);
            };

            var downHandler = function downHandler(e) {
                if (_this2.props.disabled) {
                    return;
                }

                _this2.handleResize();
                _this2.setState({ active: true });
                _this2.preventFocusState = true;

                _this2.setValueFromEvent(e, getPageX);
                document.body.addEventListener(moveEvent, moveHandler);
                document.body.addEventListener(upEvent, upHandler);
            };

            return downHandler;
        }
    }, {
        key: 'computeValueFromPageX',
        value: function computeValueFromPageX(pageX) {
            var _props = this.props,
                max = _props.max,
                min = _props.min;
            var _state = this.state,
                sliderLeft = _state.sliderLeft,
                sliderWidth = _state.sliderWidth;

            var posX = pageX - sliderLeft;
            var percentage = posX / sliderWidth;

            // Fit the percentage complete between the range [min,max] by remapping from [0, 1] to [min, min+(max-min)].
            return min + percentage * (max - min);
        }
    }, {
        key: 'normalizeValue',
        value: function normalizeValue(value) {
            if (!_.isFinite(value)) {
                return this.props.min;
            }

            var finalValue = value;
            var _props2 = this.props,
                min = _props2.min,
                max = _props2.max,
                step = _props2.step;


            var valueSetForBoundary = value === min || value === max;
            if (step && !valueSetForBoundary) {
                finalValue = this.quantizeValue(finalValue);
            }

            finalValue = _.clamp(finalValue, min, max);
            return finalValue;
        }
    }, {
        key: 'quantizeValue',
        value: function quantizeValue(value) {
            var step = this.props.step;

            var stepsCount = Math.round(value / step);
            return stepsCount * step;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _props3 = this.props,
                disabled = _props3.disabled,
                max = _props3.max,
                min = _props3.min,
                other = _objectWithoutProperties(_props3, ['disabled', 'max', 'min']);

            var _state2 = this.state,
                active = _state2.active,
                focused = _state2.focused,
                sliderWidth = _state2.sliderWidth,
                value = _state2.value;


            var sliderProps = {
                innerRef: function innerRef(c) {
                    return _this3.sliderElement = c;
                },
                onMouseDown: this.handleMouseDown,
                onTouchStart: this.handleTouchStart,
                onFocus: this.handleFocus,
                onBlur: this.handleBlur,
                onKeyDown: this.handleKeyDown,
                onWheel: this.handleWheel,
                tabIndex: disabled ? undefined : 0
            };

            var sliderTrackProps = {
                disabled: disabled,
                ref: function ref(c) {
                    return _this3.progressLinearComponent = c;
                },
                max: max,
                min: min,
                value: value
            };

            var knobTranslate = (value - min) / (max - min) * sliderWidth;
            var knobContainerProps = {
                ref: function ref(c) {
                    return _this3.knobComponent = c;
                },
                onMouseDown: this.handleMouseDown,
                onTouchStart: this.handleTouchStart,
                style: {
                    transform: 'translateX(' + knobTranslate + 'px) translateX(-50%)'
                }
            };

            var knobProps = {
                disabled: disabled,
                active: active
            };

            var knobFocusProps = {
                focused: focused
            };

            return React.createElement(
                SliderElement,
                sliderProps,
                React.createElement(SliderTrackElement, sliderTrackProps),
                React.createElement(
                    KnobContainerElement,
                    knobContainerProps,
                    React.createElement(KnobElement, knobProps),
                    React.createElement(KnobFocusElement, knobFocusProps)
                )
            );
        }
    }]);

    return Slider;
}(Component);

Slider.propTypes = {
    disabled: pt.bool,
    max: pt.number,
    min: pt.number,
    onChange: pt.func,
    step: pt.number,
    value: pt.number
};
Slider.defaultProps = {
    max: 100,
    min: 0,
    step: 1,
    value: 0,
    onChange: noop
};
export default Slider;