var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { noop } from '../utils/func';

import CalendarMonthSelector from './CalendarMonthSelector';
import CalendarMonthGrid from './CalendarMonthGrid';
import { CalendarElement, CalendarMonthGridContainerElement, PrevMonthIconButton, NextMonthIconButton, DayNamesElement, DayNamesWeekElement, DayNameElement } from './style';

var Calendar = function (_Component) {
    _inherits(Calendar, _Component);

    function Calendar(props) {
        _classCallCheck(this, Calendar);

        var _this = _possibleConstructorReturn(this, (Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call(this, props));

        _initialiseProps.call(_this);

        var getCalendarService = props.getCalendarService;

        var month = props.month || getCalendarService().getMonthOfDate(getCalendarService().getCurrentDate());

        var dayNames = getCalendarService().getDayNames();

        _this.state = {
            month: month,
            monthTransition: null,
            dayNames: dayNames
        };
        return _this;
    }

    _createClass(Calendar, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // limit width of the calendar - it won't work if the month grid has margin
            this.monthGridContainerElement.style.width = this.monthGridElement.style.width;
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // This can potentially fail in case of current transition, there should be queing implemented, but it's not easily solvable
            // Any suggestions are welcomed
            if (nextProps.month && !this.props.getCalendarService().isMonthEqual(nextProps.month, this.state.month)) {
                if (!this.isTransitioning) {
                    this.changeMonth(nextProps.month);
                }
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props = this.props,
                className = _props.className,
                getCalendarService = _props.getCalendarService,
                minDate = _props.minDate,
                maxDate = _props.maxDate,
                numberOfMonths = _props.numberOfMonths,
                showMonthSelector = _props.showMonthSelector,
                other = _objectWithoutProperties(_props, ['className', 'getCalendarService', 'minDate', 'maxDate', 'numberOfMonths', 'showMonthSelector']);

            var _state = this.state,
                month = _state.month,
                dayNames = _state.dayNames;


            var allowedRange = { minDate: minDate, maxDate: maxDate };
            var prevMonth = getCalendarService().subtractMonths(month, 1);
            var nextMonth = getCalendarService().addMonths(month, numberOfMonths);

            var calendarProps = {
                className: className
            };

            var monthGridContainerProps = {
                innerRef: function innerRef(c) {
                    return _this2.monthGridContainerElement = c;
                }
            };

            var monthGridProps = _extends({}, other, {
                getCalendarService: getCalendarService,
                month: month,
                numberOfMonths: numberOfMonths,
                onMonthTransitionEnd: this.handleMonthTransitionEnd,
                innerRef: function innerRef(c) {
                    return _this2.monthGridElement = c;
                }
            });

            return React.createElement(
                CalendarElement,
                calendarProps,
                showMonthSelector && React.createElement(CalendarMonthSelector, { month: month, onChange: this.handleMonthSelect, getCalendarService: getCalendarService }),
                React.createElement(
                    CalendarMonthGridContainerElement,
                    monthGridContainerProps,
                    React.createElement(CalendarMonthGrid, monthGridProps),
                    React.createElement(PrevMonthIconButton, {
                        onClick: this.handlePrevClick,
                        disabled: getCalendarService().isMonthDisabled(prevMonth, allowedRange)
                    }),
                    React.createElement(NextMonthIconButton, {
                        onClick: this.handleNextClick,
                        disabled: getCalendarService().isMonthDisabled(nextMonth, allowedRange)
                    }),
                    React.createElement(
                        DayNamesElement,
                        null,
                        _.times(numberOfMonths, function (n) {
                            return React.createElement(
                                DayNamesWeekElement,
                                { key: n },
                                _.map(dayNames, function (name) {
                                    return React.createElement(
                                        DayNameElement,
                                        { key: name },
                                        name
                                    );
                                })
                            );
                        })
                    )
                )
            );
        }
    }]);

    return Calendar;
}(Component);

Calendar.propTypes = {
    className: pt.string,
    getCalendarService: pt.func.isRequired,
    modifiers: pt.objectOf(pt.func),
    month: pt.any, // eslint-disable-line react/forbid-prop-types
    minDate: pt.any, // eslint-disable-line react/forbid-prop-types
    maxDate: pt.any, // eslint-disable-line react/forbid-prop-types
    numberOfMonths: pt.number,
    onMonthTransitionEnd: pt.func,
    showMonthSelector: pt.bool
};
Calendar.defaultProps = {
    modifiers: {},
    numberOfMonths: 1,
    onMonthTransitionEnd: noop
};

var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.handlePrevClick = function () {
        if (_this3.isTransitioning) {
            return;
        }

        var month = _this3.state.month;

        var prevMonth = _this3.props.getCalendarService().getPrevMonth(month);
        _this3.changeMonth(prevMonth);
    };

    this.handleNextClick = function () {
        if (_this3.isTransitioning) {
            return;
        }

        var month = _this3.state.month;

        var nextMonth = _this3.props.getCalendarService().getNextMonth(month);
        _this3.changeMonth(nextMonth);
    };

    this.handleMonthSelect = function (month) {
        if (_this3.isTransitioning) {
            return;
        }

        _this3.changeMonth(month);
    };

    this.handleMonthTransitionEnd = function () {
        _this3.isTransitioning = false;
        _this3.props.onMonthTransitionEnd();
    };

    this.changeMonth = function (month) {
        _this3.isTransitioning = true;
        _this3.setState({ month: month });
    };
};

export default Calendar;