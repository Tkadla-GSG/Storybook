var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import _ from 'lodash';
import React, { Component } from 'react';
import { PropTypes as pt } from 'prop-types';
import { KeyCode } from 'mews-js';

import ListItem from './ListItem';
import { ListElement, ListItemsWrapperElement, FilterElement, FilterInputElement, FilterPlaceholderElement } from './style';

var KEYBOARD_SEARCH_TIMEOUT = 500;

var selectedPropType = pt.oneOfType([pt.string, pt.number]);

var List = function (_Component) {
    _inherits(List, _Component);

    function List() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, List);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
            selected: _this.props.selected && (_this.props.multiselect ? _this.props.selected : [_this.props.selected]) || [],
            keyboardSearchString: '',
            filteredValues: null
        }, _this.handleKeyDown = function (event) {
            var handled = false;
            var isShift = event.shiftKey;
            var keyCode = KeyCode.getByValue(event.which);
            var direction = void 0;

            switch (keyCode) {
                case KeyCode.Enter:
                    handled = true;
                    _this.handleItemClick(_this.getActiveItem());
                    break;

                case KeyCode.Up:
                    handled = true;
                    _this.focusItem('prev');
                    break;

                case KeyCode.Down:
                    handled = true;
                    _this.focusItem('next');
                    break;

                case KeyCode.Tab:
                    direction = isShift ? 'prev' : 'next';
                    handled = _this.focusItem(direction);
                    break;

                default:
                    if (_this.props.searchable && shouldHandleKey(event)) {
                        _this.keyboardSearch(event);
                    }
                    break;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            } else {
                _this.props.onKeyDown(event);
            }
        }, _this.handleItemActivate = function (item) {
            item.domElement.focus();
        }, _this.handleItemClick = function (item) {
            if (!item) {
                return;
            }

            var value = item.props.value;


            if (_this.props.multiselect) {
                if (!_.isNil(value)) {
                    var selected = _.xor([].concat(_toConsumableArray(_this.state.selected)), [value]);
                    _this.setState({ selected: selected });
                    _this.props.onChange(selected);
                }
            } else if (_this.props.selectable) {
                var _selected = _this.state.selected;
                if (!_.isNil(value) && _selected[0] !== value) {
                    _selected[0] = value;
                    _this.setState({ selected: _selected });
                    _this.props.onChange(_selected);
                }
            }

            _this.handleItemActivate(item);
            _this.props.onItemClick(item);
        }, _this.handleFilterChange = function (e) {
            var filterString = e.target.value;
            _this.setState({ filterString: filterString });

            var normalizedFilterString = normalize(filterString);

            if (_.isEmpty(normalizedFilterString)) {
                _this.setState({ filteredValues: null });
            } else {
                var filteredItems = _.filter(_this.items, function (i) {
                    return _.includes(normalize(i.getPrimaryText()), normalizedFilterString);
                });
                _this.setState({ filteredValues: filteredItems.map(function (i) {
                        return i.props.value;
                    }) });
            }
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(List, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.selected && !_.isEmpty(_.difference(this.state.selected, nextProps.selected))) {
                this.setState({ selected: this.props.multiselect ? nextProps.selected : [nextProps.selected] });
            }
        }
    }, {
        key: 'findItemByValue',
        value: function findItemByValue(value) {
            return _.find(this.items, function (item) {
                return item.value === value;
            });
        }
    }, {
        key: 'getActiveItem',
        value: function getActiveItem() {
            return _.find(this.items, function (item) {
                return item.domElement === document.activeElement;
            });
        }
    }, {
        key: 'getActiveItemIndex',
        value: function getActiveItemIndex() {
            return _.findIndex(this.items, function (item) {
                return item.domElement === document.activeElement;
            });
        }
    }, {
        key: 'focusItem',
        value: function focusItem(direction) {
            var firstIndex = 0;
            var lastIndex = this.items.length - 1;
            var activeItemIndex = this.getActiveItemIndex();

            var index = void 0;
            if (activeItemIndex === -1) {
                index = direction === 'next' ? firstIndex : lastIndex;
            } else {
                index = activeItemIndex + (direction === 'next' ? +1 : -1);
            }

            var isOutOfRange = index < firstIndex || index > lastIndex;
            if (!this.props.cyclicNavigation && isOutOfRange) {
                return false;
            }

            if (index < firstIndex) {
                index = lastIndex;
            }
            if (index > lastIndex) {
                index = firstIndex;
            }

            this.handleItemActivate(this.items[index]);
            return true;
        }
    }, {
        key: 'keyboardSearch',
        value: function keyboardSearch(event) {
            var _this2 = this;

            var nextChar = String.fromCharCode(event.which);

            var searchString = normalize(this.state.keyboardSearchString + nextChar);
            if (_.isEmpty(searchString)) {
                return;
            }

            if (!this.itemSearchValues) {
                this.itemSearchValues = _.map(this.items, function (i) {
                    return normalize(i.getPrimaryText());
                });
            }

            if (this.clearKeyboardSearchTimeout) {
                clearTimeout(this.clearKeyboardSearchTimeout);
            }

            this.clearKeyboardSearchTimeout = setTimeout(function () {
                _this2.itemSearchValues = null;
                _this2.clearKeyboardSearchTimeout = null;
                _this2.setState({ keyboardSearchString: '' });
            }, KEYBOARD_SEARCH_TIMEOUT);

            var matchIndex = _.findIndex(this.itemSearchValues, function (v) {
                return _.startsWith(v, searchString);
            });
            if (matchIndex !== -1) {
                var match = this.items[matchIndex];
                this.handleItemActivate(match);
            }

            this.setState({ keyboardSearchString: searchString });
        }
    }, {
        key: 'renderNodes',
        value: function renderNodes() {
            var _this3 = this;

            var filteredValues = this.state.filteredValues;

            this.items = [];

            return React.Children.map(this.props.children, function (c, index) {
                if (_.isNil(c)) {
                    return c;
                }

                if (c.type === _this3.props.itemType) {
                    var value = c.props.value;

                    return React.cloneElement(c, {
                        dense: _this3.props.dense,
                        key: index,
                        onClick: _this3.handleItemClick,
                        ref: function ref(item) {
                            if (item) {
                                _this3.items.push(item);
                            }
                        },
                        selected: _.includes(_this3.state.selected, value),
                        tabIndex: _this3.props.navigable ? 0 : null,
                        multiselect: _this3.props.multiselect,
                        hidden: filteredValues && !_.includes(filteredValues, value)
                    });
                }

                return c;
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var _props = this.props,
                _innerRef = _props.innerRef,
                filterable = _props.filterable,
                other = _objectWithoutProperties(_props, ['innerRef', 'filterable']);

            delete other.itemType;

            var listProps = _extends({}, other, {
                innerRef: function innerRef(c) {
                    _this4.list = c;
                    _innerRef(c);
                },
                onKeyDown: this.handleKeyDown
            });

            var filter = void 0;
            if (filterable) {
                var filterString = this.state.filterString;


                filter = React.createElement(
                    FilterElement,
                    null,
                    React.createElement(FilterInputElement, { onChange: this.handleFilterChange }),
                    _.isEmpty(filterString) && React.createElement(
                        FilterPlaceholderElement,
                        null,
                        this.props.filterPlaceholder
                    )
                );
            }

            return React.createElement(
                ListElement,
                null,
                filter,
                React.createElement(
                    ListItemsWrapperElement,
                    listProps,
                    this.renderNodes()
                )
            );
        }
    }]);

    return List;
}(Component);

List.propTypes = {
    children: pt.node,
    innerRef: pt.func,
    navigable: pt.bool,
    onItemClick: pt.func,
    onChange: pt.func,

    cyclicNavigation: pt.bool,
    searchable: pt.bool,
    selectable: pt.bool,
    multiselect: pt.bool,
    filterable: pt.bool,

    dense: pt.bool,

    itemType: pt.any,
    selected: pt.oneOfType([selectedPropType, pt.arrayOf(selectedPropType)])
};
List.defaultProps = {
    innerRef: _.noop,
    navigable: false,
    onItemClick: _.noop,
    onChange: _.noop,
    onKeyDown: _.noop,

    cyclicNavigation: false,
    searchable: false,
    selectable: false,

    itemType: ListItem
};
export default List;


function normalize(string) {
    return _.chain(string).deburr().toLower().trim().value();
}

function shouldHandleKey(event) {
    var char = String.fromCharCode(event.keyCode);
    var isNonUsefulKey = event.keyCode <= 31;

    return char && char.length && !isNonUsefulKey && !isMetaKey(event) && !isFnLockKey(event) && !hasModifierKey(event);
}

function isMetaKey(e) {
    return e.keyCode >= 91 && e.keyCode <= 93;
}

function isFnLockKey(e) {
    return e.keyCode >= 112 && e.keyCode <= 145;
}

function hasModifierKey(e) {
    return e.ctrlKey || e.metaKey || e.altKey;
}